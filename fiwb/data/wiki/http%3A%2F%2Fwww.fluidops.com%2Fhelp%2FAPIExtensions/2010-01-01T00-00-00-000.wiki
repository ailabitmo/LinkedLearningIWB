== API extensions ==

The {{PRODUCT}} supports the dynamic extension of the API with custom extensions. These extensions can be used to expose services through the API framework, which are then available using the CLI or through the RESTful endpoint. 

The platform's API framework is organized in a layered architecture as depicted in the following figure. Core modules of the hierarchical design are clients, certain pluggable proxies, the service endpoints and finally the invocation handler.

<img src="../images/help/SDK/SDK-api-framework.png" />

Java based clients access the exposed functionality from the API's public interface and invoke a method. The method call is then redirected through one of the available pluggable proxies to the actual corresponding service endpoint. Before the invocation parameters are passed on to the invocation handler certain configurable security constraints are required to be met: Clients need to authenticate at the endpoint using one of the available login methods, in particular Basic Authentication for HTTP based interaction or RMI login at the Java RMI service endpoint. Note that this layer is also the entry point for non-Java applications, such as for instance .NET applications.

When the security constraints are met the actual method call and corresponding parameters enter the invocation handler. The invocation handler is responsible for performing cross cutting concerns such as session management, further checks on security constraints and aspect handling. Moreover, this layer takes care of the actual method invocation on the API's public implementation.

This layered architecture approach was chosen to unify various endpoints into one middleware system: while having several entry points in the upper layers, the actual method invocation is bundled in the invocation handler. Each method call performed on one of the various endpoints is mapped to a generic Java invocation and passes the invocation handler. Hence, the exposed functionality can only be accessed after all constraints and concerns are being handled and thus a secure access to the API is guaranteed.

Below, we describe in detail how custom service implementations can be exposed using the following steps:

# Implement the service you want to expose, as a Java class
# Implement a service factory for this service
# Register your service factory to META-INF services

Details and examples for each step can be found below.

=== Implementation of the service ===

The service itself is a Java class exposing its functionality via public functions. In addition, your service class must implement the ''com.fluidops.api.dynamic.Service'' interface. Methods to be exposed need to be annotated with the ''@Doc'' annotation, all available parameters must be annotated with the ''@Par'' annotation. Note in particular that all parameters need to be serializable, in fact it is recommended to restrict to simple types only.

Consider the ''MyService'' example below as illustration.

<source>
public class MyService implements Service {

	@Doc(value="Do Something prints an test message to stdout")
	public void doSomething() {
		System.out.println("test");
        }
	
	@Doc(value="Print the passed string to stdout and return it")
	public String helloWorld(
			@Par(name = "s", type = "string", desc = "just a test parameter", isRequired = true)String s) {
		System.out.println(s);              
		return s;
	}
}
</source>

If your service class in addition implements the ''java.io.Closeable'' interface, the close() method is invoked at shutdown time of to eventually free any resources.

=== Implementation of the service factory ===

The service factory is a Java class that is used to instantiate your service implementation and to provide some metadata. The class must implement the ''com.fluidops.api.dynamic.ServiceFactory'' interface and provide a default constructor. The ''service name'' is the actual name under which the service becomes available through the API framework, e.g. in the CLI. Typically, the service name corresponds to the simple name of the service class. Note that when the service is exposed, it automatically becomes accessible via get<nowiki><service name></nowiki>, e.g. if your service is called MyService, it is exposed as getMyService.

Consider the example below as an illustration.

<source>
public class MyServiceFactory implements ServiceFactory {

	@Override
	public String getServiceName() {
		return "MyService";
	}

	@Override
	public Service create() {
		return new MyService();
	}

	@Override
	public String getDocumentation() {
		return "This is a demo test API";
	}
}
</source>

=== Registering the service ===

In the {{PRODUCT}} we use the [http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html Java SPI mechanism] to register the service factory implementations which are then used to instantiate the particular services. The service factory implementation needs to be registered in the ''META-INF/services'' location. 

If not present, create a file ''META-INF/services/com.fluidops.api.dynamic.ServiceFactory'' and specify the fully qualified classname of your service factory (one item per line). The final thing to do is to put your services on the classpath of the {{PRODUCT}}, e.g. as a [[Help:Solutions | solution]]. These service factories are then picked up by Java's ''ServiceLoader'' at startup of the platform, and will be registered as a service.

Consider the following example as illustration:

<source>
com.fluidops.api.MyServiceFactory
</source>

Once the service is registered, it can be accessed for instance from the [[Help:CLI| CLI]], e.g. for our example with

<source>
> cli getMyService helloWorld -s hello
</source>